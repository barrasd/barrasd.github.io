<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triangle with Fixed Area</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }

        canvas {
            border: 1px solid #ccc;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <canvas id="triangleCanvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById('triangleCanvas');
        const ctx = canvas.getContext('2d');

        // Initial vertices of the triangle
        let vertices = [
            { x: 200, y: 300 }, // Vertex A
            { x: 400, y: 300 }, // Vertex B
            { x: 300, y: 100 }  // Vertex C
        ];

        let fixedArea = calculateArea(vertices);
        let draggingVertex = null;

        function calculateArea([A, B, C]) {
            return Math.abs((A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y)) / 2);
        }

        function adjustVertices(draggedIndex) {
            const A = vertices[(draggedIndex + 1) % 3];
            const B = vertices[(draggedIndex + 2) % 3];
            const C = vertices[draggedIndex];

            const newArea = calculateArea([A, B, C]);
            const scaleFactor = Math.sqrt(fixedArea / newArea);

            // Adjust the other two vertices to maintain the same area
            if (C.x === A.x || C.y === A.y) {
                const axis = C.x === A.x ? 'y' : 'x';
                B[axis] = A[axis] + scaleFactor * (B[axis] - A[axis]);
            } else {
                const axis = C.y === A.y ? 'x' : 'y';
                B[axis] = A[axis] + scaleFactor * (B[axis] - A[axis]);
            }
        }

        function drawTriangle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            vertices.forEach(v => ctx.lineTo(v.x, v..show) then() that repeats Dr
